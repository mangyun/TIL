
### arguments(ES5 문법)
모든 파라미터를 []안에 넣을 수 있다. ES6의 Rest parameter가 있어서 덜 쓰인다.
```js
function 함수(a,b,c){
  for (let i = 0; i < arguments.length; i++){ //각 변수가 arguments로 배열화된다고 생각하자.
    console.log(arguments[i])// arg[0] = 2, arg[1] = 3, arg[2] = 4 
  }
}
함수(2,3,4);
```

### default parameter(ES6 문법)
파라미터를 실수로 안 적거나 없을 경우, 기본값을 줄 수 있다.  
1. 기본 값이나 수식들이 들어갈 수 있다.
```js
function 더하기 (a, b = 10){ //(a, b = 2 * 5), (a, b = 2 * a) 이런것도 다됨.
  console.log(a + b)
}
더하기(1);//b를 안 적었지만, 기본값으로 인해 11이다.
```
2. 반환된 함수도 들어갈 수 있다.
```js
function 임시함수(){
  return 10; //반환값
}
function 더하기 (a, b = 임시함수() ){ //반환값을 넣는다.
  console.log(a + b)
}
더하기(3); //기본값 b = 10을 더해 13이 된다.
```

### Rest parameter(ES6 문법)
arguments와 동일하지만, 변수를 나눌 수 있다.   
파라미터면 무조건 Rest이고, 나머지는 전부 Spread이다.
```js
function 함수2(a, b, ...파라미터들){// 주의할 것은 ...은 한번만 사용가능하고, 맨 마지막에 와야한다.
  console.log(파라미터들)
}
함수2(1,2,3,4,5,6,7); //a, b자리인 1, 2를 제외하고, 3,4,5,6,7 출력
```

예시) 글자를 오브젝트로 변환해보자.
```js
function 글자세기(글) {
        var 결과 = {};
        [...글].forEach(function(글자) { // ['a', 'a', 'b', 'b', 'c', 'c', 'c']
            if (결과[글자] > 0) { // object에서 데이터를 뽑는 법. 결과[a], 결과[b], 결과[c]
                결과[글자]++ // 있다면 1 더하기
            } else {
                결과[글자] = 1 // 없다면, 0
            }
        });
        console.log(결과);
    }
    글자세기('aabbccc'); // {a: 2, b: 2, c: 3}
```




<br>




### primitive 타입
문자나 숫자같이, 자료 자체가 변수에 저장된다.
```js
var name = 'john'; //문자
var age = 20; //숫자
```

### reference 타입
array, object 같이, 자료가 저쪽에 있다라는 화살표(레퍼런스)가 변수에 저장된다.
```js
var 사람 = { name : 'Kim' }; //Kim이라는 데이터가 저쪽에 있습니다~라는 정보가 저장, 중괄호 하나에 레퍼런스 하나라고 생각하자.
```

### reference 예시
1. 레퍼런스가 같음
```js
var 이름1 = { name : '김' }; //레퍼런스 저장
var 이름2 = 이름1; // 레퍼런스 복사
이름1.name = '박'; // 같은 레퍼런스로 인해, 이름2.name = '박' 이 된다.
```
2. 값은 같아도, 레퍼런스가 다름
```js
var 이름1 = { name : '김' }; //예로, 레퍼런스 A에 저장
var 이름2 = { name : '김' }; //예로, 레퍼런스 B에 저장
이름1 == 이름2 // false, 값은 같아도 서로 각각의 레퍼런스를 가진다.
```

3. 함수를 이용해 object를 변경한다.  
파라미터는 일종의 변수처럼 생성되고 사라지는 존재라고 보고, 쉽게 말해 var변수이다.  
여기서는 파라미터인 obj에, { name : 'park' };을 재할당했으므로, 이름1과 obj가 서로 다른 레퍼런스를 가지게 된다.
```js
var 이름1 = { name : '김' }; //레퍼런스 저장
function 변경(obj){
  obj = { name : 'park' }; // 다시 파라미터에서 레퍼런스
}
변경(이름1); //사람의 시점에서는 이렇지만, JS 시점에선 변경(var obj = 이름1);이다.
```
